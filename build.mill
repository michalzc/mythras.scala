//| mill-version: 1.0.3
//| mvnDeps:
//|   - io.circe::circe-yaml-v12:0.16.1
//|   - io.circe::circe-parser:0.14.14
//|   - com.github.sommeri:less4j:1.17.2
//|   - com.lihaoyi::mill-contrib-versionfile:$MILL_VERSION
//|   - com.goyeau::mill-scalafix::0.6.0

package build
import com.github.sommeri.less4j.core.ThreadUnsafeLessCompiler
import mill.*
import mill.api.Task.Simple
import mill.scalajslib.*
import mill.scalajslib.api.{ModuleKind, Report}
import mill.scalalib.*
import com.goyeau.mill.scalafix.ScalafixModule
import scala.jdk.CollectionConverters.*
import mill.contrib.versionfile.VersionFileModule

extension [E, A](self: Either[E, A]) {
  def orThrow = self match
    case Right(result)       => result
    case Left(ex: Throwable) => throw ex
    case Left(other)         => throw new Exception(other.toString)

}

def fixAll = mill.scalalib.scalafmt.ScalafmtModule

trait MScalaJSModule extends ScalaJSModule, SbtModule, ScalafixModule {
  def scalaVersion   = "3.3.6"
  def scalaJSVersion = "1.19.0"

  def scalacOptions = Seq(
    "-explain",
    "-Wunused:all"
  )
}

object `version-file` extends VersionFileModule

object `scala-types` extends MScalaJSModule {}

object `mythras-shared` extends MScalaJSModule {
  def mvnDeps = Seq(
    mvn"org.typelevel::cats-core::2.13.0"
  )

  object test extends ScalaJSTests, TestModule.ScalaTest, SbtTests {
    def mvnDeps = Seq(
      mvn"org.scalatest::scalatest::3.2.19"
    )

  }
}

object mythras extends MScalaJSModule {
  def moduleDeps = Seq(
    `scala-types`,
    `mythras-shared`
  )

  override def moduleKind = ModuleKind.ESModule

  def mvnDeps = Seq(
    mvn"org.scala-js::scalajs-dom::2.2.0"
  )
}

object `foundry-package` extends Module {
  import io.circe.yaml.v12.parser.parse

  def yamlSources = Task.Source("src/main/yaml")
  def resources   = Task.Source("src/main/resources")
  def jsSources   = Task.Source("src/main/js")
  def lessSources = Task.Source("src/main/less")

  def buildDev = Task {
    val jsReport = mythras.fastLinkJS()

    val (cssProblems, files) = buildSystem(
      Task.dest,
      jsReport,
      jsSources().path,
      lessSources().path,
      resources().path,
      yamlSources().path,
      `version-file`.currentVersion().toString
    )
    cssProblems.foreach(problem => Task.log.warn(s"Less compiler: ${problem}"))

    files
  }

  def buildProd = Task {
    val jsReport = mythras.fullLinkJS()

    val (cssProblems, files) = buildSystem(
      Task.dest,
      jsReport,
      jsSources().path,
      lessSources().path,
      resources().path,
      yamlSources().path,
      `version-file`.currentVersion().toString
    )
    cssProblems.foreach(problem => Task.log.warn(s"Less compiler: ${problem}"))

    files
  }

  def buildSystem(
      dest: os.Path,
      jsLinkReport: Report,
      jsSources: os.Path,
      lessSources: os.Path,
      resourcePath: os.Path,
      yamlSources: os.Path,
      version: String
  ) = {
    val resources                       = copyFiles(dest, resourcePath)
    val jsFiles                         = copyFiles(dest / "modules", jsSources)
    val yamlFiles                       = convertYamls(dest, yamlSources)
    val moduleFiles                     = copyFiles(dest / "modules", jsLinkReport.dest.path)
    val (cssProblems, compiledCssFiles) = compileLess(dest / "css", lessSources)
    val systemJson                      = convertSystem(dest, yamlSources, version)

    cssProblems -> (resources ++ jsFiles ++ yamlFiles ++ moduleFiles ++ compiledCssFiles :+ systemJson)
  }

  def copyFiles(dest: os.Path, source: os.Path) = os
    .walk(source)
    .filter(_.toIO.isFile)
    .map(p => p -> dest / p.relativeTo(source))
    .map { (sourceFile, destFile) =>
      os.copy.over(sourceFile, destFile, createFolders = true)
      PathRef(destFile)
    }

  def convertYamls(dest: os.Path, source: os.Path) = {
    val yamlFiles = os
      .walk(source)
      .filter(p =>
        p.toIO.isFile() && ((p.ext.toLowerCase == "yaml" || p.ext.toLowerCase == "yml") && p.baseName != "system")
      )
      .map(p =>
        p -> (os.Path(p.toNIO.getParent) / s"${p.baseName}.json")
          .relativeTo(source)
      )

    yamlFiles.map { (file, relativeFile) =>
      val cnt     = os.read(file)
      val json    = parse(cnt).orThrow
      val outPath = dest / relativeFile
      os.write.over(outPath, json.spaces2, createFolders = true)
      PathRef(outPath)
    }
  }

  def compileLess(desc: os.Path, source: os.Path) = {
    val compiler  = new ThreadUnsafeLessCompiler()
    val inputFile = source / "mythras.less"
    val result    = compiler.compile(inputFile.toIO)
    val cssPath   = desc / "mythras.css"
    os.write(cssPath, result.getCss)
    val mapPath = desc / "mythras.css.map"
    os.write(mapPath, result.getSourceMap)
    result.getWarnings.asScala.map(_.getMessage) -> List(
      PathRef(mapPath),
      PathRef(mapPath)
    )
  }

  def convertSystem(dest: os.Path, source: os.Path, version: String) = {
    import io.circe.syntax.*

    val json         = parse(os.read(source / "system.yaml")).orThrow
    val modifiedJson = ("version" -> version.asJson) +: json.asObject.get
    val destFile     = dest / "system.json"
    os.write(destFile, modifiedJson.asJson.spaces2)
    PathRef(destFile)
  }
}
