## Me
How to combine the js generated by scala.js with additional js files? Somethin like rollup and minification.

## AI Assistant
I'll help you understand how to combine JS generated by Scala.js with additional JS files, including bundling and minification techniques.

Based on your current setup using the `FoundryScalaJsPlugin`, you're already handling Scala.js output files, but you want to add functionality to bundle these with other JS files and minify the result.

## Adding JS Bundling and Minification to Scala.js

To combine Scala.js output with additional JS files and perform minification, you can use popular JavaScript bundling tools like Rollup, Webpack, or esbuild. Let's explore how to integrate these with your SBT build:

### Option 1: Using Rollup with SBT

Let's add Rollup integration to your plugin:

1. First, add dependencies to your build:

```scala
// In project/plugins.sbt
addSbtPlugin("org.scala-js" % "sbt-scalajs" % "1.13.2")
libraryDependencies += "org.scala-js" %% "scalajs-env-nodejs" % "1.4.0"
```

2. Then modify your plugin to integrate Rollup:

```scala
// In FoundryScalaJsPlugin.scala
object autoImport {
  // Existing settings
  lazy val rollupConfig = settingKey[File]("Rollup configuration file")
  lazy val bundleJS = taskKey[Seq[File]]("Bundle JS files using Rollup")
  lazy val externalJsFiles = settingKey[Seq[File]]("Additional JS files to include in the bundle")
}

// Add to projectSettings
rollupConfig := baseDirectory.value / "rollup.config.js",
externalJsFiles := Seq(),
bundleJS := {
  val log = streams.value.log
  val jsFile = (Compile / fastLinkJS / scalaJSLinkerOutputDirectory).value / 
    jsTask.value.data.publicModules.head.jsFileName
  
  // Create a temporary rollup command file
  val rollupCmd = s"npx rollup -c ${rollupConfig.value.getAbsolutePath} " +
    s"--input ${jsFile.getAbsolutePath} " +
    s"--file ${(distOutput.value / "bundle.js").getAbsolutePath} " +
    s"--format iife"
  
  if (Process(rollupCmd).! == 0) {
    Seq(distOutput.value / "bundle.js")
  } else {
    log.error("Rollup bundling failed")
    Nil
  }
}
```

3. Create a rollup.config.js in your project root:

```javascript
// rollup.config.js
import resolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import terser from '@rollup/plugin-terser';

export default {
  plugins: [
    resolve(),
    commonjs(),
    terser() // For minification
  ]
};
```

### Option 2: Using esbuild (lighter and faster)

You can also use esbuild which is faster than Rollup:

```scala
// In FoundryScalaJsPlugin.scala
bundleJS := {
  val log = streams.value.log
  val jsFile = (Compile / fastLinkJS / scalaJSLinkerOutputDirectory).value / 
    jsTask.value.data.publicModules.head.jsFileName
  val externalFiles = externalJsFiles.value.map(_.getAbsolutePath).mkString(" ")
  val outputFile = (distOutput.value / "bundle.js").getAbsolutePath
  
  val esbuildCmd = s"npx esbuild ${jsFile.getAbsolutePath} $externalFiles --bundle --minify --outfile=$outputFile"
  
  if (Process(esbuildCmd).! == 0) {
    Seq(new File(outputFile))
  } else {
    log.error("esbuild bundling failed")
    Nil
  }
}
```

### Integration with your existing build process

To integrate with your existing `copyFiles` method, you'll need to modify it to include the bundled JS files:

```scala
def copyFiles(
  jsTask: TaskKey[Attributed[Report]],
  output: SettingKey[File],
): Def.Initialize[Task[Seq[(File, File)]]] = Def.task {
  // Original code...
  
  // Replace jsFiles with bundled version when appropriate
  val jsFiles = if (bundleJsEnabled.value) {
    // Run the bundling task and map the output
    transformPaths(Set(bundleJS.value.head.getParentFile), output.value / "modules")(bundleJS.value)
  } else {
    transformPaths(Set(jsOutDir), output.value / "modules")(scripts)
  }
  
  // Rest of the original code...
}
```

### Adding to your project

You'll also need to add a setting to enable/disable bundling:

```scala
lazy val bundleJsEnabled = settingKey[Boolean]("Whether to bundle JS files")

// In project settings
bundleJsEnabled := false, // Set to true when you want bundling
```

## Setup Requirements

For either approach, you'll need to:

1. Install Node.js on your development machine
2. Add the necessary npm packages to your project:

```
npm init -y
npm install --save-dev rollup @rollup/plugin-node-resolve @rollup/plugin-commonjs @rollup/plugin-terser
```

Or for esbuild:

```
npm init -y
npm install --save-dev esbuild
```

## Usage in Your Build

Once integrated, you can use these tasks in your build:

```scala
// In build.sbt
myProject / Compile / bundleJsEnabled := true
myProject / Compile / externalJsFiles := Seq(
  file("path/to/external1.js"),
  file("path/to/external2.js")
)
```

Then running `sbt dist` should include the bundled and minified JS files.

Would you like me to explain any specific part of this integration in more detail?

## Me
How to add source maps to esbuild?

## AI Assistant
# Adding Source Maps to esbuild

Adding source maps to esbuild is straightforward and can be achieved by adding the appropriate flag to your esbuild command. Let me show you how to modify your `bundleJS` task to include source map generation:

## Modifying the `bundleJS` Task to Include Source Maps

Here's how you can update your `bundleJS` task to generate source maps with esbuild:

```scala
bundleJS := {
  val log = streams.value.log
  val jsFile = (Compile / fastLinkJS / scalaJSLinkerOutputDirectory).value / 
    jsTask.value.data.publicModules.head.jsFileName
  val externalFiles = externalJsFiles.value.map(_.getAbsolutePath).mkString(" ")
  val outputFile = (distOutput.value / "bundle.js").getAbsolutePath
  
  // Add sourcemap flag to the esbuild command
  val esbuildCmd = s"""npx esbuild ${jsFile.getAbsolutePath} $externalFiles --bundle --minify --sourcemap --outfile=$outputFile"""
  
  log.info(s"Running: $esbuildCmd")
  
  if (Process(esbuildCmd).! == 0) {
    // Return both the bundle.js and bundle.js.map files
    Seq(new File(outputFile), new File(s"$outputFile.map"))
  } else {
    log.error("esbuild bundling failed")
    Nil
  }
}
```

The key change here is adding the `--sourcemap` flag to the esbuild command, which will generate a separate `.map` file. Also note that we're now returning both the JavaScript bundle and its source map from the task.

## Additional Source Map Options

esbuild offers several source map related options that you might find useful:

### 1. Inline Source Maps

If you prefer to have the source map inlined in the generated bundle rather than as a separate file:

```scala
val esbuildCmd = s"""npx esbuild ${jsFile.getAbsolutePath} $externalFiles --bundle --minify --sourcemap=inline --outfile=$outputFile"""
```

### 2. Including Source Contents

To include the original source content in the map file (useful for debugging without needing the original files):

```scala
val esbuildCmd = s"""npx esbuild ${jsFile.getAbsolutePath} $externalFiles --bundle --minify --sourcemap --sources-content=true --outfile=$outputFile"""
```

### 3. External Source Maps with Custom URL

If you want to specify a custom URL for the source map:

```scala
val esbuildCmd = s"""npx esbuild ${jsFile.getAbsolutePath} $externalFiles --bundle --minify --sourcemap --sourcemap-base-url=https://example.com/maps/ --outfile=$outputFile"""
```

## Integration with Your Plugin

To fully integrate this with your existing plugin, you'll need to make sure the source map files are properly handled in your `copyFiles` method:

```scala
def copyFiles(
  jsTask: TaskKey[Attributed[Report]],
  output: SettingKey[File],
): Def.Initialize[Task[Seq[(File, File)]]] = Def.task {
  // Original code...
  
  val jsFiles = if (bundleJsEnabled.value) {
    // Run bundling and get both JS and source map files
    val bundledFiles = bundleJS.value
    transformPaths(Set(bundledFiles.head.getParentFile), output.value / "modules")(bundledFiles)
  } else {
    transformPaths(Set(jsOutDir), output.value / "modules")(scripts)
  }
  
  // Rest of the original code...
}
```

## Adding Source Map Options as Settings

For more flexibility, you could expose source map options as settings in your plugin:

```scala
object autoImport {
  // Existing settings
  lazy val sourceMapsEnabled = settingKey[Boolean]("Whether to generate source maps")
  lazy val sourceMapsInline = settingKey[Boolean]("Whether to inline source maps in the JS file")
  lazy val sourceMapsIncludeContent = settingKey[Boolean]("Whether to include source content in maps")
}

// Default settings
sourceMapsEnabled := true,
sourceMapsInline := false,
sourceMapsIncludeContent := true,

// Then use them in bundleJS
bundleJS := {
  // ...
  val sourceMapOptions = if (sourceMapsEnabled.value) {
    if (sourceMapsInline.value) "--sourcemap=inline" 
    else "--sourcemap" + (if (sourceMapsIncludeContent.value) " --sources-content=true" else "")
  } else ""
  
  val esbuildCmd = s"""npx esbuild ${jsFile.getAbsolutePath} $externalFiles --bundle --minify $sourceMapOptions --outfile=$outputFile"""
  // ...
}
```

This approach gives users of your plugin fine-grained control over how source maps are generated.

With these changes, your Scala.js output will be bundled with any additional JS files, minified, and include source maps for debugging purposes.
